//! FFI serialization layer for cross-language model export.
//!
//! This module provides serialization using Protocol Buffers for cross-language
//! deserialization. The protobuf types are generated by micropb from wasmib.proto.
//!
//! # Design Principles
//!
//! 1. **Flat structures** - No nested references, use indices instead
//! 2. **Compact enums** - Use u8 representation for enums
//! 3. **Inline strings** - Strings stored directly in protobuf fields
//! 4. **Versioned** - Schema version in envelope for forward compatibility
//! 5. **Self-contained** - Indices can be rebuilt from serialized data

use alloc::boxed::Box;
use alloc::string::{String, ToString};
use alloc::vec::Vec;
use core::fmt;
use micropb::{MessageDecode, MessageEncode, PbDecoder};
use wasmib_core::model::{
    Access, BaseType, BitDefinitions, DefVal, EnumValues, IndexItem, IndexSpec, Model, ModuleId,
    NodeDefinition, NodeId, NodeKind, NotificationId, ObjectId, OidNode, RangeBound,
    ResolvedModule, ResolvedNotification, ResolvedObject, ResolvedType, Revision, SizeConstraint,
    Status, TypeId, UnresolvedImport as CoreUnresolvedImport, UnresolvedImportReason,
    UnresolvedIndex as CoreUnresolvedIndex,
    UnresolvedNotificationObject as CoreUnresolvedNotificationObject,
    UnresolvedOid as CoreUnresolvedOid, UnresolvedType as CoreUnresolvedType, ValueConstraint,
};

// Include generated protobuf types (with warnings suppressed for generated code)
#[allow(
    unused_imports,
    unused_parens,
    unused_variables,
    non_camel_case_types,
    non_snake_case,
    clippy::all,
    clippy::pedantic
)]
mod proto {
    include!(concat!(env!("OUT_DIR"), "/wasmib.rs"));
}
use proto::wasmib_;

/// Current schema version. Bump on any breaking change to serialized format.
pub const SCHEMA_VERSION: u32 = 2;

/// Re-export the generated types for external use
pub use wasmib_::*;

/// Create a serialized model from a resolved Model.
#[must_use]
#[allow(clippy::cast_possible_truncation)] // Counts will never exceed u32::MAX
pub fn from_model(model: &Model, fingerprint: Option<[u8; 32]>) -> SerializedModel {
    // 1. Serialize modules
    let modules: Vec<_> = model.modules().map(serialize_module).collect();

    // 2. Serialize nodes
    let nodes: Vec<_> = (0..model.node_count())
        .filter_map(|i| {
            wasmib_core::model::NodeId::from_index(i)
                .and_then(|id| model.get_node(id))
                .map(serialize_node)
        })
        .collect();

    // 3. Serialize types
    let types: Vec<_> = (0..model.type_count())
        .filter_map(|i| {
            wasmib_core::model::TypeId::from_index(i)
                .and_then(|id| model.get_type(id))
                .map(serialize_type)
        })
        .collect();

    // 4. Serialize objects
    let objects: Vec<_> = (0..model.object_count())
        .filter_map(|i| {
            wasmib_core::model::ObjectId::from_index(i)
                .and_then(|id| model.get_object(id))
                .map(serialize_object)
        })
        .collect();

    // 5. Serialize notifications
    let notifications: Vec<_> = (0..model.notification_count())
        .filter_map(|i| {
            wasmib_core::model::NotificationId::from_index(i)
                .and_then(|id| model.get_notification(id))
                .map(serialize_notification)
        })
        .collect();

    // 6. Get roots
    let roots: Vec<_> = model.root_ids().iter().map(|id| id.to_raw()).collect();

    // 7. Get unresolved references with details
    let unresolved = model.unresolved();

    // Serialize unresolved details
    let unresolved_import_details: Vec<_> = unresolved
        .imports
        .iter()
        .map(serialize_unresolved_import)
        .collect();
    let unresolved_type_details: Vec<_> = unresolved
        .types
        .iter()
        .map(serialize_unresolved_type)
        .collect();
    let unresolved_oid_details: Vec<_> = unresolved
        .oids
        .iter()
        .map(serialize_unresolved_oid)
        .collect();
    let unresolved_index_details: Vec<_> = unresolved
        .indexes
        .iter()
        .map(serialize_unresolved_index)
        .collect();
    let unresolved_notif_details: Vec<_> = unresolved
        .notification_objects
        .iter()
        .map(serialize_unresolved_notif)
        .collect();

    // Use struct literal for repeated fields, then set scalar fields
    SerializedModel {
        r#version: SCHEMA_VERSION,
        r#fingerprint: fingerprint.map_or_else(Vec::new, |fp| fp.to_vec()),
        modules,
        nodes,
        types,
        objects,
        notifications,
        roots,
        r#unresolved_imports: unresolved.imports.len() as u32,
        r#unresolved_types: unresolved.types.len() as u32,
        r#unresolved_oids: unresolved.oids.len() as u32,
        r#unresolved_indexes: unresolved.indexes.len() as u32,
        r#unresolved_notification_objects: unresolved.notification_objects.len() as u32,
        unresolved_import_details,
        unresolved_type_details,
        unresolved_oid_details,
        unresolved_index_details,
        unresolved_notif_details,
    }
}

/// Serialize a model to protobuf bytes.
///
/// # Panics
///
/// Panics if protobuf encoding fails (only possible on out-of-memory).
#[must_use]
pub fn to_bytes(model: &Model, fingerprint: Option<[u8; 32]>) -> Vec<u8> {
    let serialized = from_model(model, fingerprint);
    let mut buf = Vec::new();
    serialized
        .encode(&mut micropb::PbEncoder::new(&mut buf))
        .expect("serialization should not fail");
    buf
}

/// Error during protobuf deserialization.
#[derive(Debug)]
pub enum DecodeError {
    /// Protobuf decode failed.
    ProtobufDecode(micropb::DecodeError<core::convert::Infallible>),
    /// Invalid enum value.
    InvalidEnumValue { field: &'static str, value: u32 },
    /// Invalid ID (zero where non-zero expected).
    InvalidId { field: &'static str },
}

impl fmt::Display for DecodeError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::ProtobufDecode(e) => write!(f, "protobuf decode error: {e:?}"),
            Self::InvalidEnumValue { field, value } => {
                write!(f, "invalid enum value {value} for field {field}")
            }
            Self::InvalidId { field } => write!(f, "invalid zero ID for field {field}"),
        }
    }
}

impl From<micropb::DecodeError<core::convert::Infallible>> for DecodeError {
    fn from(e: micropb::DecodeError<core::convert::Infallible>) -> Self {
        Self::ProtobufDecode(e)
    }
}

/// Deserialize a model from protobuf bytes.
///
/// # Errors
///
/// Returns an error if the protobuf data is invalid or contains invalid enum values.
pub fn from_bytes(bytes: &[u8]) -> Result<Model, DecodeError> {
    let mut msg = SerializedModel::default();
    msg.decode(&mut PbDecoder::new(bytes), bytes.len())?;
    to_model(msg)
}

/// Get the schema version from serialized bytes without fully decoding.
///
/// This reads only the version field from the protobuf envelope.
///
/// # Errors
///
/// Returns an error if the protobuf header cannot be read.
pub fn get_version(bytes: &[u8]) -> Result<u32, DecodeError> {
    let mut msg = SerializedModel::default();
    msg.decode(&mut PbDecoder::new(bytes), bytes.len())?;
    Ok(msg.r#version)
}

/// Get the fingerprint from serialized bytes without fully decoding.
///
/// # Errors
///
/// Returns an error if the protobuf header cannot be read.
pub fn get_fingerprint(bytes: &[u8]) -> Result<Option<[u8; 32]>, DecodeError> {
    let mut msg = SerializedModel::default();
    msg.decode(&mut PbDecoder::new(bytes), bytes.len())?;
    if msg.r#fingerprint.is_empty() {
        Ok(None)
    } else if msg.r#fingerprint.len() == 32 {
        let mut fp = [0u8; 32];
        fp.copy_from_slice(&msg.r#fingerprint);
        Ok(Some(fp))
    } else {
        Ok(None) // Invalid fingerprint length, treat as missing
    }
}

/// Convert a `SerializedModel` to a Model.
fn to_model(msg: SerializedModel) -> Result<Model, DecodeError> {
    // Create a new model and populate it by deserializing each entity.
    let mut model = Model::new();

    // 1. Deserialize modules
    for module_msg in msg.r#modules {
        let module = deserialize_module(module_msg)?;
        model
            .add_module(module)
            .map_err(|_| DecodeError::InvalidId {
                field: "module capacity",
            })?;
    }

    // 2. Deserialize nodes
    for node_msg in msg.r#nodes {
        let node = deserialize_node(node_msg)?;
        model.add_node(node).map_err(|_| DecodeError::InvalidId {
            field: "node capacity",
        })?;
    }

    // 3. Deserialize types
    for type_msg in msg.r#types {
        let typ = deserialize_type(type_msg)?;
        model.add_type(typ).map_err(|_| DecodeError::InvalidId {
            field: "type capacity",
        })?;
    }

    // 4. Deserialize objects
    for object_msg in msg.r#objects {
        let obj = deserialize_object(object_msg)?;
        model.add_object(obj).map_err(|_| DecodeError::InvalidId {
            field: "object capacity",
        })?;
    }

    // 5. Deserialize notifications
    for notif_msg in msg.r#notifications {
        let notif = deserialize_notification(notif_msg)?;
        model
            .add_notification(notif)
            .map_err(|_| DecodeError::InvalidId {
                field: "notification capacity",
            })?;
    }

    // 6. Set roots
    for root_raw in msg.r#roots {
        if let Some(root_id) = NodeId::from_raw(root_raw) {
            model.add_root(root_id);
        }
    }

    // Note: Unresolved references are not fully deserialized. The counts are stored
    // but the actual references are primarily for diagnostics during resolution.

    Ok(model)
}

fn deserialize_module(msg: SerializedModule) -> Result<ResolvedModule, DecodeError> {
    if msg.r#name.is_empty() {
        return Err(DecodeError::InvalidId {
            field: "module.name",
        });
    }
    let name: Box<str> = msg.r#name.into();

    let mut module = ResolvedModule::new(name);
    module.last_updated = optional_str(&msg.r#last_updated);
    module.contact_info = optional_str(&msg.r#contact_info);
    module.organization = optional_str(&msg.r#organization);
    module.description = optional_str(&msg.r#description);
    module.revisions = msg
        .r#revisions
        .into_iter()
        .filter_map(deserialize_revision)
        .collect();

    Ok(module)
}

fn deserialize_revision(msg: SerializedRevision) -> Option<Revision> {
    if msg.r#date.is_empty() || msg.r#description.is_empty() {
        return None;
    }
    let date: Box<str> = msg.r#date.into();
    let description: Box<str> = msg.r#description.into();
    Some(Revision::new(date, description))
}

/// Convert a string to Option<Box<str>>, returning None for empty strings.
fn optional_str(s: &str) -> Option<Box<str>> {
    if s.is_empty() { None } else { Some(s.into()) }
}

#[allow(clippy::cast_possible_truncation)] // Enum values fit in u8
fn deserialize_node(msg: SerializedNode) -> Result<OidNode, DecodeError> {
    let kind = NodeKind::from_u8(msg.r#kind as u8).ok_or(DecodeError::InvalidEnumValue {
        field: "node.kind",
        value: msg.r#kind,
    })?;

    let mut node = OidNode::new(msg.r#subid, NodeId::from_raw(msg.r#parent));
    node.kind = kind;
    node.children = msg
        .r#children
        .into_iter()
        .filter_map(NodeId::from_raw)
        .collect();
    node.definitions = msg
        .r#definitions
        .into_iter()
        .filter_map(deserialize_node_def)
        .collect();

    Ok(node)
}

fn deserialize_node_def(msg: SerializedNodeDef) -> Option<NodeDefinition> {
    let module = ModuleId::from_raw(msg.r#module)?;
    if msg.r#label.is_empty() {
        return None;
    }
    let label: Box<str> = msg.r#label.into();
    let mut def = NodeDefinition::new(module, label);
    def.object = ObjectId::from_raw(msg.r#object);
    def.notification = NotificationId::from_raw(msg.r#notification);
    Some(def)
}

#[allow(clippy::cast_possible_truncation)] // Enum values fit in u8
fn deserialize_type(msg: SerializedType) -> Result<ResolvedType, DecodeError> {
    let module = ModuleId::from_raw(msg.r#module).ok_or(DecodeError::InvalidId {
        field: "type.module",
    })?;
    if msg.r#name.is_empty() {
        return Err(DecodeError::InvalidId { field: "type.name" });
    }
    let name: Box<str> = msg.r#name.clone().into();
    let base = BaseType::from_u8(msg.r#base as u8).ok_or(DecodeError::InvalidEnumValue {
        field: "type.base",
        value: msg.r#base,
    })?;
    let status = Status::from_u8(msg.r#status as u8).ok_or(DecodeError::InvalidEnumValue {
        field: "type.status",
        value: msg.r#status,
    })?;

    let mut typ = ResolvedType::new(name, module, base);
    typ.parent_type = TypeId::from_raw(msg.r#parent);
    typ.status = status;
    typ.is_textual_convention = msg.r#is_tc;
    typ.hint = optional_str(&msg.r#hint);
    typ.description = optional_str(&msg.r#description);

    // Deserialize size constraint (use accessor method for optional field)
    if let Some(size_msg) = msg.r#size() {
        typ.size = Some(deserialize_size_constraint(size_msg));
    }

    // Deserialize value range constraint (use accessor method for optional field)
    if let Some(range_msg) = msg.r#range() {
        typ.value_range = Some(deserialize_value_constraint(range_msg));
    }

    // Deserialize enum values
    if !msg.r#enum_values.is_empty() {
        let values: Vec<(i64, Box<str>)> = msg
            .r#enum_values
            .into_iter()
            .filter_map(|ev| {
                if ev.r#name.is_empty() {
                    None
                } else {
                    Some((ev.r#value, ev.r#name.into()))
                }
            })
            .collect();
        if !values.is_empty() {
            typ.enum_values = Some(EnumValues::new(values));
        }
    }

    // Deserialize bit definitions
    if !msg.r#bit_defs.is_empty() {
        let bits: Vec<(u32, Box<str>)> = msg
            .r#bit_defs
            .into_iter()
            .filter_map(|bd| {
                if bd.r#name.is_empty() {
                    None
                } else {
                    Some((bd.r#position, bd.r#name.into()))
                }
            })
            .collect();
        if !bits.is_empty() {
            typ.bit_defs = Some(BitDefinitions::new(bits));
        }
    }

    Ok(typ)
}

#[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)] // Protobuf uses i64, sizes fit u32
fn deserialize_size_constraint(msg: &SerializedConstraint) -> SizeConstraint {
    SizeConstraint {
        ranges: msg
            .r#ranges
            .iter()
            .map(|r| (r.r#min as u32, r.r#max as u32))
            .collect(),
    }
}

fn deserialize_value_constraint(msg: &SerializedConstraint) -> ValueConstraint {
    ValueConstraint {
        ranges: msg
            .r#ranges
            .iter()
            .map(|r| (RangeBound::Signed(r.r#min), RangeBound::Signed(r.r#max)))
            .collect(),
    }
}

#[allow(clippy::cast_possible_truncation)] // Enum values fit in u8
fn deserialize_object(msg: SerializedObject) -> Result<ResolvedObject, DecodeError> {
    let node = NodeId::from_raw(msg.r#node).ok_or(DecodeError::InvalidId {
        field: "object.node",
    })?;
    let module = ModuleId::from_raw(msg.r#module).ok_or(DecodeError::InvalidId {
        field: "object.module",
    })?;
    if msg.r#name.is_empty() {
        return Err(DecodeError::InvalidId {
            field: "object.name",
        });
    }
    let name: Box<str> = msg.r#name.clone().into();
    let access = Access::from_u8(msg.r#access as u8).ok_or(DecodeError::InvalidEnumValue {
        field: "object.access",
        value: msg.r#access,
    })?;
    let status = Status::from_u8(msg.r#status as u8).ok_or(DecodeError::InvalidEnumValue {
        field: "object.status",
        value: msg.r#status,
    })?;

    let mut obj = ResolvedObject::new(node, module, name, TypeId::from_raw(msg.r#type_id), access);
    obj.status = status;
    obj.description = optional_str(&msg.r#description);
    obj.units = optional_str(&msg.r#units);
    obj.reference = optional_str(&msg.r#reference);
    obj.augments = NodeId::from_raw(msg.r#augments);

    // Deserialize index (use accessor method for optional field)
    if let Some(index_msg) = msg.r#index() {
        let items: Vec<IndexItem> = index_msg
            .r#items
            .iter()
            .filter_map(|item| {
                NodeId::from_raw(item.r#object).map(|obj| IndexItem::new(obj, item.r#implied))
            })
            .collect();
        if !items.is_empty() {
            obj.index = Some(IndexSpec::new(items));
        }
    }

    // Deserialize defval (use accessor method for optional field)
    if let Some(defval_msg) = msg.r#defval() {
        obj.defval = deserialize_defval(defval_msg);
    }

    // Deserialize inline enum
    if !msg.r#inline_enum.is_empty() {
        let values: Vec<(i64, Box<str>)> = msg
            .r#inline_enum
            .into_iter()
            .filter_map(|ev| {
                if ev.r#name.is_empty() {
                    None
                } else {
                    Some((ev.r#value, ev.r#name.into()))
                }
            })
            .collect();
        if !values.is_empty() {
            obj.inline_enum = Some(EnumValues::new(values));
        }
    }

    // Deserialize inline bits
    if !msg.r#inline_bits.is_empty() {
        let bits: Vec<(u32, Box<str>)> = msg
            .r#inline_bits
            .into_iter()
            .filter_map(|bd| {
                if bd.r#name.is_empty() {
                    None
                } else {
                    Some((bd.r#position, bd.r#name.into()))
                }
            })
            .collect();
        if !bits.is_empty() {
            obj.inline_bits = Some(BitDefinitions::new(bits));
        }
    }

    Ok(obj)
}

fn deserialize_defval(msg: &SerializedDefVal) -> Option<DefVal> {
    match msg.r#kind {
        // Use accessor methods which return Option<&T> for optional fields
        0 => msg.r#int_val().copied().map(DefVal::Integer),
        1 => msg.r#uint_val().copied().map(DefVal::Unsigned),
        2 => msg
            .r#str_val()
            .filter(|s| !s.is_empty())
            .map(|s| DefVal::String(s.as_str().into())),
        3 => msg.r#raw_str().map(|s| DefVal::HexString(s.clone())),
        4 => msg.r#raw_str().map(|s| DefVal::BinaryString(s.clone())),
        5 => msg
            .r#str_val()
            .filter(|s| !s.is_empty())
            .map(|s| DefVal::Enum(s.as_str().into())),
        6 => {
            let bits: Vec<Box<str>> = msg
                .r#bits_val
                .iter()
                .filter(|s| !s.is_empty())
                .map(|s| s.as_str().into())
                .collect();
            Some(DefVal::Bits(bits))
        }
        7 => Some(DefVal::OidRef {
            node: msg.r#node_val().and_then(|&v| NodeId::from_raw(v)),
            symbol: msg
                .r#str_val()
                .filter(|s| !s.is_empty())
                .map(|s| s.as_str().into()),
        }),
        _ => None,
    }
}

#[allow(clippy::cast_possible_truncation)] // Enum values fit in u8
fn deserialize_notification(
    msg: SerializedNotification,
) -> Result<ResolvedNotification, DecodeError> {
    let node = NodeId::from_raw(msg.r#node).ok_or(DecodeError::InvalidId {
        field: "notification.node",
    })?;
    let module = ModuleId::from_raw(msg.r#module).ok_or(DecodeError::InvalidId {
        field: "notification.module",
    })?;
    if msg.r#name.is_empty() {
        return Err(DecodeError::InvalidId {
            field: "notification.name",
        });
    }
    let name: Box<str> = msg.r#name.into();
    let status = Status::from_u8(msg.r#status as u8).ok_or(DecodeError::InvalidEnumValue {
        field: "notification.status",
        value: msg.r#status,
    })?;

    let mut notif = ResolvedNotification::new(node, module, name);
    notif.status = status;
    notif.description = optional_str(&msg.r#description);
    notif.reference = optional_str(&msg.r#reference);
    notif.objects = msg
        .r#objects
        .into_iter()
        .filter_map(NodeId::from_raw)
        .collect();

    Ok(notif)
}

/// Convert a string reference to `String` for protobuf serialization.
fn str_to_proto(s: &str) -> String {
    s.to_string()
}

/// Convert an `Option<Box<str>>` to `String`, returning empty string for None.
fn optional_str_to_proto(s: Option<&str>) -> String {
    s.map_or_else(String::new, ToString::to_string)
}

fn serialize_module(module: &ResolvedModule) -> SerializedModule {
    SerializedModule {
        r#name: str_to_proto(&module.name),
        r#last_updated: optional_str_to_proto(module.last_updated.as_deref()),
        r#contact_info: optional_str_to_proto(module.contact_info.as_deref()),
        r#organization: optional_str_to_proto(module.organization.as_deref()),
        r#description: optional_str_to_proto(module.description.as_deref()),
        r#revisions: module.revisions.iter().map(serialize_revision).collect(),
    }
}

fn serialize_revision(rev: &Revision) -> SerializedRevision {
    SerializedRevision {
        r#date: str_to_proto(&rev.date),
        r#description: str_to_proto(&rev.description),
    }
}

fn serialize_node(node: &OidNode) -> SerializedNode {
    SerializedNode {
        r#subid: node.subid,
        r#parent: node.parent.map_or(0, wasmib_core::model::NodeId::to_raw),
        r#children: node.children.iter().map(|id| id.to_raw()).collect(),
        r#kind: u32::from(node.kind.as_u8()),
        r#definitions: node.definitions.iter().map(serialize_node_def).collect(),
    }
}

fn serialize_node_def(def: &wasmib_core::model::NodeDefinition) -> SerializedNodeDef {
    SerializedNodeDef {
        r#module: def.module.to_raw(),
        r#label: str_to_proto(&def.label),
        r#object: def.object.map_or(0, wasmib_core::model::ObjectId::to_raw),
        r#notification: def
            .notification
            .map_or(0, wasmib_core::model::NotificationId::to_raw),
    }
}

fn serialize_object(obj: &ResolvedObject) -> SerializedObject {
    let mut result = SerializedObject {
        r#node: obj.node.to_raw(),
        r#module: obj.module.to_raw(),
        r#name: str_to_proto(&obj.name),
        r#type_id: obj.type_id.map_or(0, wasmib_core::model::TypeId::to_raw),
        r#access: u32::from(obj.access.as_u8()),
        r#status: u32::from(obj.status.as_u8()),
        r#description: optional_str_to_proto(obj.description.as_deref()),
        r#units: optional_str_to_proto(obj.units.as_deref()),
        r#reference: optional_str_to_proto(obj.reference.as_deref()),
        r#augments: obj.augments.map_or(0, wasmib_core::model::NodeId::to_raw),
        r#inline_enum: obj.inline_enum.as_ref().map_or_else(Vec::new, |e| {
            e.values
                .iter()
                .map(|(v, name)| EnumValue {
                    r#value: *v,
                    r#name: str_to_proto(name),
                })
                .collect()
        }),
        r#inline_bits: obj.inline_bits.as_ref().map_or_else(Vec::new, |b| {
            b.bits
                .iter()
                .map(|(pos, name)| BitDef {
                    r#position: *pos,
                    r#name: str_to_proto(name),
                })
                .collect()
        }),
        ..Default::default()
    };

    // Set optional fields using setters (which update _has)
    if let Some(index) = &obj.index {
        result.set_index(serialize_index(index));
    }
    if let Some(defval) = &obj.defval {
        result.set_defval(serialize_defval(defval));
    }

    result
}

fn serialize_index(index: &wasmib_core::model::IndexSpec) -> SerializedIndex {
    SerializedIndex {
        r#items: index.items.iter().map(serialize_index_item).collect(),
    }
}

fn serialize_index_item(item: &IndexItem) -> SerializedIndexItem {
    SerializedIndexItem {
        r#object: item.object.to_raw(),
        r#implied: item.implied,
    }
}

fn serialize_defval(defval: &DefVal) -> SerializedDefVal {
    let mut result = SerializedDefVal::default();

    match defval {
        DefVal::Integer(v) => {
            result.set_kind(0);
            result.set_int_val(*v);
        }
        DefVal::Unsigned(v) => {
            result.set_kind(1);
            result.set_uint_val(*v);
        }
        DefVal::String(s) => {
            result.set_kind(2);
            result.set_str_val(str_to_proto(s));
        }
        DefVal::HexString(s) => {
            result.set_kind(3);
            result.set_raw_str(s.clone());
        }
        DefVal::BinaryString(s) => {
            result.set_kind(4);
            result.set_raw_str(s.clone());
        }
        DefVal::Enum(s) => {
            result.set_kind(5);
            result.set_str_val(str_to_proto(s));
        }
        DefVal::Bits(names) => {
            result.set_kind(6);
            result.r#bits_val = names.iter().map(|s| str_to_proto(s)).collect();
        }
        DefVal::OidRef { node, symbol } => {
            result.set_kind(7);
            if let Some(s) = symbol {
                result.set_str_val(str_to_proto(s));
            }
            if let Some(id) = node {
                result.set_node_val(id.to_raw());
            }
        }
    }

    result
}

fn serialize_type(typ: &ResolvedType) -> SerializedType {
    let mut result = SerializedType {
        r#module: typ.module.to_raw(),
        r#name: str_to_proto(&typ.name),
        r#base: u32::from(typ.base.as_u8()),
        r#parent: typ
            .parent_type
            .map_or(0, wasmib_core::model::TypeId::to_raw),
        r#status: u32::from(typ.status.as_u8()),
        r#is_tc: typ.is_textual_convention,
        r#hint: optional_str_to_proto(typ.hint.as_deref()),
        r#description: optional_str_to_proto(typ.description.as_deref()),
        r#enum_values: typ.enum_values.as_ref().map_or_else(Vec::new, |e| {
            e.values
                .iter()
                .map(|(v, name)| EnumValue {
                    r#value: *v,
                    r#name: str_to_proto(name),
                })
                .collect()
        }),
        r#bit_defs: typ.bit_defs.as_ref().map_or_else(Vec::new, |b| {
            b.bits
                .iter()
                .map(|(pos, name)| BitDef {
                    r#position: *pos,
                    r#name: str_to_proto(name),
                })
                .collect()
        }),
        ..Default::default()
    };

    // Set optional constraint fields
    if let Some(size) = &typ.size {
        result.set_size(serialize_size_constraint(size));
    }
    if let Some(range) = &typ.value_range {
        result.set_range(serialize_value_constraint(range));
    }

    result
}

fn serialize_size_constraint(
    constraint: &wasmib_core::model::SizeConstraint,
) -> SerializedConstraint {
    SerializedConstraint {
        r#ranges: constraint
            .ranges
            .iter()
            .map(|(min, max)| Range {
                r#min: i64::from(*min),
                r#max: i64::from(*max),
            })
            .collect(),
    }
}

fn serialize_value_constraint(
    constraint: &wasmib_core::model::ValueConstraint,
) -> SerializedConstraint {
    SerializedConstraint {
        r#ranges: constraint
            .ranges
            .iter()
            .map(|(min, max)| Range {
                r#min: range_bound_to_i64(min),
                r#max: range_bound_to_i64(max),
            })
            .collect(),
    }
}

#[allow(clippy::cast_possible_wrap)] // MIB range values won't exceed i64::MAX
fn range_bound_to_i64(bound: &wasmib_core::model::RangeBound) -> i64 {
    match bound {
        wasmib_core::model::RangeBound::Signed(v) => *v,
        wasmib_core::model::RangeBound::Unsigned(v) => *v as i64,
    }
}

fn serialize_notification(notif: &ResolvedNotification) -> SerializedNotification {
    SerializedNotification {
        r#node: notif.node.to_raw(),
        r#module: notif.module.to_raw(),
        r#name: str_to_proto(&notif.name),
        r#status: u32::from(notif.status.as_u8()),
        r#description: optional_str_to_proto(notif.description.as_deref()),
        r#reference: optional_str_to_proto(notif.reference.as_deref()),
        r#objects: notif.objects.iter().map(|id| id.to_raw()).collect(),
    }
}

fn serialize_unresolved_import(imp: &CoreUnresolvedImport) -> UnresolvedImport {
    UnresolvedImport {
        r#importing_module: imp.importing_module.to_raw(),
        r#from_module: str_to_proto(&imp.from_module),
        r#symbol: str_to_proto(&imp.symbol),
        r#reason: match imp.reason {
            UnresolvedImportReason::ModuleNotFound => 0,
            UnresolvedImportReason::SymbolNotExported => 1,
        },
    }
}

fn serialize_unresolved_type(typ: &CoreUnresolvedType) -> UnresolvedType {
    UnresolvedType {
        r#module: typ.module.to_raw(),
        r#referrer: str_to_proto(&typ.referrer),
        r#referenced: str_to_proto(&typ.referenced),
    }
}

fn serialize_unresolved_oid(oid: &CoreUnresolvedOid) -> UnresolvedOid {
    UnresolvedOid {
        r#module: oid.module.to_raw(),
        r#definition: str_to_proto(&oid.definition),
        r#component: str_to_proto(&oid.component),
    }
}

fn serialize_unresolved_index(idx: &CoreUnresolvedIndex) -> UnresolvedIndex {
    UnresolvedIndex {
        r#module: idx.module.to_raw(),
        r#row: str_to_proto(&idx.row),
        r#index_object: str_to_proto(&idx.index_object),
    }
}

fn serialize_unresolved_notif(
    notif: &CoreUnresolvedNotificationObject,
) -> UnresolvedNotificationObject {
    UnresolvedNotificationObject {
        r#module: notif.module.to_raw(),
        r#notification: str_to_proto(&notif.notification),
        r#object: str_to_proto(&notif.object),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use wasmib_core::model::{
        Access, BaseType, Model, NodeKind, OidNode, ResolvedModule, ResolvedType, Status,
    };

    #[test]
    fn test_round_trip_empty_model() {
        let model = Model::new();
        let bytes = to_bytes(&model, None);
        let restored = from_bytes(&bytes).expect("decode should succeed");

        assert_eq!(restored.module_count(), 0);
        assert_eq!(restored.node_count(), 0);
        assert_eq!(restored.type_count(), 0);
        assert_eq!(restored.object_count(), 0);
        assert_eq!(restored.notification_count(), 0);
    }

    #[test]
    fn test_round_trip_with_fingerprint() {
        let model = Model::new();
        let fp = [42u8; 32];
        let bytes = to_bytes(&model, Some(fp));

        // Verify we can extract fingerprint
        let extracted_fp = get_fingerprint(&bytes).expect("should extract fingerprint");
        assert_eq!(extracted_fp, Some(fp));

        // Verify full decode works
        let restored = from_bytes(&bytes).expect("decode should succeed");
        assert_eq!(restored.module_count(), 0);
    }

    #[test]
    fn test_round_trip_with_content() {
        let mut model = Model::new();

        // Add a module
        let mod_name: Box<str> = "TEST-MIB".into();
        let module = ResolvedModule::new(mod_name);
        let mod_id = model.add_module(module).expect("should add module");

        // Add a node
        let mut node = OidNode::new(1, None);
        node.kind = NodeKind::Scalar;
        let node_id = model.add_node(node).expect("should add node");
        model.add_root(node_id);

        // Add a type
        let type_name: Box<str> = "TestType".into();
        let mut typ = ResolvedType::new(type_name, mod_id, BaseType::Integer32);
        typ.description = Some("A test type".into());
        model.add_type(typ).expect("should add type");

        // Serialize and deserialize
        let bytes = to_bytes(&model, None);
        let restored = from_bytes(&bytes).expect("decode should succeed");

        // Verify counts
        assert_eq!(restored.module_count(), 1);
        assert_eq!(restored.node_count(), 1);
        assert_eq!(restored.type_count(), 1);

        // Verify module name
        let restored_mod = restored.get_module_by_name("TEST-MIB");
        assert!(restored_mod.is_some(), "Module TEST-MIB should be found");

        // Verify node kind
        let root = restored.roots().next().expect("should have root");
        assert_eq!(root.kind, NodeKind::Scalar);
    }

    #[test]
    fn test_serialize_empty_model() {
        let model = Model::new();
        let serialized = from_model(&model, None);

        assert_eq!(serialized.r#version, SCHEMA_VERSION);
        assert!(serialized.r#fingerprint.is_empty());
        assert!(serialized.r#modules.is_empty());
        assert!(serialized.r#nodes.is_empty());
        assert!(serialized.r#types.is_empty());
        assert!(serialized.r#objects.is_empty());
        assert!(serialized.r#notifications.is_empty());
        assert!(serialized.r#roots.is_empty());
    }

    #[test]
    fn test_serialize_with_fingerprint() {
        let model = Model::new();
        let fp = [42u8; 32];
        let serialized = from_model(&model, Some(fp));

        assert_eq!(serialized.r#fingerprint.as_slice(), &fp);
    }

    #[test]
    fn test_to_bytes_empty_model() {
        let model = Model::new();
        let bytes = to_bytes(&model, None);

        // Should produce non-empty protobuf bytes
        assert!(!bytes.is_empty());
    }

    #[test]
    fn test_node_kind_round_trip() {
        // NodeKind has 10 variants: Internal, Node, Scalar, Table, Row, Column,
        // Notification, Group, Compliance, Capabilities
        for i in 0..10u8 {
            let kind = NodeKind::from_u8(i).expect("valid NodeKind value");
            assert_eq!(kind.as_u8(), i);
        }
        assert!(NodeKind::from_u8(10).is_none());
    }

    #[test]
    fn test_access_round_trip() {
        // Access has 6 variants: NotAccessible, AccessibleForNotify, ReadOnly,
        // ReadWrite, ReadCreate, WriteOnly
        for i in 0..6u8 {
            let access = Access::from_u8(i).expect("valid Access value");
            assert_eq!(access.as_u8(), i);
        }
        assert!(Access::from_u8(6).is_none());
    }

    #[test]
    fn test_status_round_trip() {
        // Status has 3 variants: Current, Deprecated, Obsolete
        for i in 0..3u8 {
            let status = Status::from_u8(i).expect("valid Status value");
            assert_eq!(status.as_u8(), i);
        }
        assert!(Status::from_u8(3).is_none());
    }

    #[test]
    fn test_base_type_round_trip() {
        // BaseType has 12 variants: Integer32, Unsigned32, Counter32, Counter64,
        // Gauge32, TimeTicks, IpAddress, OctetString, ObjectIdentifier, Bits,
        // Opaque, Unknown
        for i in 0..12u8 {
            let base = BaseType::from_u8(i).expect("valid BaseType value");
            assert_eq!(base.as_u8(), i);
        }
        assert!(BaseType::from_u8(12).is_none());
    }
}
