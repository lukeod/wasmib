//! FFI serialization layer for cross-language model export.
//!
//! This module provides serialization using Protocol Buffers for cross-language
//! deserialization. The protobuf types are generated by micropb from wasmib.proto.
//!
//! # Design Principles
//!
//! 1. **Flat structures** - No nested references, use indices instead
//! 2. **Compact enums** - Use u8 representation for enums
//! 3. **String table** - All strings are interned, referenced by u32 ID
//! 4. **Versioned** - Schema version in envelope for forward compatibility
//! 5. **Self-contained** - Indices can be rebuilt from serialized data

use alloc::string::String;
use alloc::vec::Vec;
use micropb::MessageEncode;
use wasmib_core::model::{
    DefVal, IndexItem, Model, OidNode, ResolvedModule, ResolvedNotification, ResolvedObject,
    ResolvedType, Revision, StringInterner,
};

// Include generated protobuf types
include!(concat!(env!("OUT_DIR"), "/wasmib.rs"));

/// Current schema version. Bump on any breaking change to serialized format.
pub const SCHEMA_VERSION: u32 = 1;

/// Re-export the generated types for external use
pub use wasmib_::*;

/// Create a serialized model from a resolved Model.
#[must_use]
pub fn from_model(model: &Model, fingerprint: Option<[u8; 32]>) -> SerializedModel {
    // 1. Serialize string interner
    let (strings_data, strings_offsets) = serialize_strings(model.strings());

    // 2. Serialize modules
    let modules: Vec<_> = model.modules().map(serialize_module).collect();

    // 3. Serialize nodes
    let nodes: Vec<_> = (0..model.node_count())
        .filter_map(|i| {
            wasmib_core::model::NodeId::from_index(i)
                .and_then(|id| model.get_node(id))
                .map(serialize_node)
        })
        .collect();

    // 4. Serialize types
    let types: Vec<_> = (0..model.type_count())
        .filter_map(|i| {
            wasmib_core::model::TypeId::from_index(i)
                .and_then(|id| model.get_type(id))
                .map(serialize_type)
        })
        .collect();

    // 5. Serialize objects
    let objects: Vec<_> = (0..model.object_count())
        .filter_map(|i| {
            wasmib_core::model::ObjectId::from_index(i)
                .and_then(|id| model.get_object(id))
                .map(|obj| serialize_object(obj, model))
        })
        .collect();

    // 6. Serialize notifications
    let notifications: Vec<_> = (0..model.notification_count())
        .filter_map(|i| {
            wasmib_core::model::NotificationId::from_index(i)
                .and_then(|id| model.get_notification(id))
                .map(serialize_notification)
        })
        .collect();

    // 7. Get roots
    let roots: Vec<_> = model.root_ids().iter().map(|id| id.to_raw()).collect();

    // 8. Get unresolved counts
    let unresolved = model.unresolved();

    // Use struct literal for repeated fields, then set scalar fields
    SerializedModel {
        r#version: SCHEMA_VERSION,
        r#fingerprint: fingerprint.map_or_else(Vec::new, |fp| fp.to_vec()),
        r#strings_data: strings_data,
        r#strings_offsets: strings_offsets,
        r#modules: modules,
        r#nodes: nodes,
        r#types: types,
        r#objects: objects,
        r#notifications: notifications,
        r#roots: roots,
        r#unresolved_imports: unresolved.imports.len() as u32,
        r#unresolved_types: unresolved.types.len() as u32,
        r#unresolved_oids: unresolved.oids.len() as u32,
        r#unresolved_indexes: unresolved.indexes.len() as u32,
        r#unresolved_notification_objects: unresolved.notification_objects.len() as u32,
    }
}

/// Serialize a model to protobuf bytes.
#[must_use]
pub fn to_bytes(model: &Model, fingerprint: Option<[u8; 32]>) -> Vec<u8> {
    let serialized = from_model(model, fingerprint);
    let mut buf = Vec::new();
    serialized
        .encode(&mut micropb::PbEncoder::new(&mut buf))
        .expect("serialization should not fail");
    buf
}

/// Serialize the string interner to (data, offsets).
fn serialize_strings(interner: &StringInterner) -> (String, Vec<StringOffset>) {
    let (data, offsets) = interner.export_parts();

    // Convert offsets to StringOffset messages
    let offset_msgs: Vec<StringOffset> = if offsets.is_empty() {
        Vec::new()
    } else {
        offsets
            .windows(2)
            .map(|w| StringOffset {
                r#start: w[0],
                r#end: w[1],
            })
            .chain(core::iter::once(StringOffset {
                r#start: *offsets.last().unwrap_or(&0),
                r#end: data.len() as u32,
            }))
            .collect()
    };

    (data, offset_msgs)
}

fn serialize_module(module: &ResolvedModule) -> SerializedModule {
    SerializedModule {
        r#name: module.name.to_raw(),
        r#last_updated: module.last_updated.map_or(0, |id| id.to_raw()),
        r#contact_info: module.contact_info.map_or(0, |id| id.to_raw()),
        r#organization: module.organization.map_or(0, |id| id.to_raw()),
        r#description: module.description.map_or(0, |id| id.to_raw()),
        r#revisions: module.revisions.iter().map(serialize_revision).collect(),
    }
}

fn serialize_revision(rev: &Revision) -> SerializedRevision {
    SerializedRevision {
        r#date: rev.date.to_raw(),
        r#description: rev.description.to_raw(),
    }
}

fn serialize_node(node: &OidNode) -> SerializedNode {
    SerializedNode {
        r#subid: node.subid,
        r#parent: node.parent.map_or(0, |id| id.to_raw()),
        r#children: node.children.iter().map(|id| id.to_raw()).collect(),
        r#kind: u32::from(node.kind.as_u8()),
        r#definitions: node.definitions.iter().map(serialize_node_def).collect(),
    }
}

fn serialize_node_def(def: &wasmib_core::model::NodeDefinition) -> SerializedNodeDef {
    SerializedNodeDef {
        r#module: def.module.to_raw(),
        r#label: def.label.to_raw(),
        r#object: def.object.map_or(0, |id| id.to_raw()),
        r#notification: def.notification.map_or(0, |id| id.to_raw()),
    }
}

fn serialize_object(obj: &ResolvedObject, model: &Model) -> SerializedObject {
    let mut result = SerializedObject {
        r#node: obj.node.to_raw(),
        r#module: obj.module.to_raw(),
        r#name: obj.name.to_raw(),
        r#type_id: obj.type_id.map_or(0, |id| id.to_raw()),
        r#access: u32::from(obj.access.as_u8()),
        r#status: u32::from(obj.status.as_u8()),
        r#description: obj.description.map_or(0, |id| id.to_raw()),
        r#units: obj.units.map_or(0, |id| id.to_raw()),
        r#reference: obj.reference.map_or(0, |id| id.to_raw()),
        r#augments: obj.augments.map_or(0, |id| id.to_raw()),
        r#inline_enum: obj.inline_enum.as_ref().map_or_else(Vec::new, |e| {
            e.values
                .iter()
                .map(|(v, id)| EnumValue {
                    r#value: *v,
                    r#name: id.to_raw(),
                })
                .collect()
        }),
        r#inline_bits: obj.inline_bits.as_ref().map_or_else(Vec::new, |b| {
            b.bits
                .iter()
                .map(|(pos, id)| BitDef {
                    r#position: *pos,
                    r#name: id.to_raw(),
                })
                .collect()
        }),
        ..Default::default()
    };

    // Set optional fields using setters (which update _has)
    if let Some(index) = &obj.index {
        result.set_index(serialize_index(index));
    }
    if let Some(defval) = &obj.defval {
        result.set_defval(serialize_defval(defval, model));
    }

    result
}

fn serialize_index(index: &wasmib_core::model::IndexSpec) -> SerializedIndex {
    SerializedIndex {
        r#items: index.items.iter().map(serialize_index_item).collect(),
    }
}

fn serialize_index_item(item: &IndexItem) -> SerializedIndexItem {
    SerializedIndexItem {
        r#object: item.object.to_raw(),
        r#implied: item.implied,
    }
}

fn serialize_defval(defval: &DefVal, _model: &Model) -> SerializedDefVal {
    let mut result = SerializedDefVal::default();

    match defval {
        DefVal::Integer(v) => {
            result.set_kind(0);
            result.set_int_val(*v);
        }
        DefVal::Unsigned(v) => {
            result.set_kind(1);
            result.set_uint_val(*v);
        }
        DefVal::String(id) => {
            result.set_kind(2);
            result.set_str_val(id.to_raw());
        }
        DefVal::HexString(s) => {
            result.set_kind(3);
            result.set_raw_str(s.clone());
        }
        DefVal::BinaryString(s) => {
            result.set_kind(4);
            result.set_raw_str(s.clone());
        }
        DefVal::Enum(id) => {
            result.set_kind(5);
            result.set_str_val(id.to_raw());
        }
        DefVal::Bits(ids) => {
            result.set_kind(6);
            result.r#bits_val = ids.iter().map(|id| id.to_raw()).collect();
        }
        DefVal::OidRef { node, symbol } => {
            result.set_kind(7);
            if let Some(id) = symbol {
                result.set_str_val(id.to_raw());
            }
            if let Some(id) = node {
                result.set_node_val(id.to_raw());
            }
        }
    }

    result
}

fn serialize_type(typ: &ResolvedType) -> SerializedType {
    let mut result = SerializedType {
        r#module: typ.module.to_raw(),
        r#name: typ.name.to_raw(),
        r#base: u32::from(typ.base.as_u8()),
        r#parent: typ.parent_type.map_or(0, |id| id.to_raw()),
        r#status: u32::from(typ.status.as_u8()),
        r#is_tc: typ.is_textual_convention,
        r#hint: typ.hint.map_or(0, |id| id.to_raw()),
        r#description: typ.description.map_or(0, |id| id.to_raw()),
        r#enum_values: typ.enum_values.as_ref().map_or_else(Vec::new, |e| {
            e.values
                .iter()
                .map(|(v, id)| EnumValue {
                    r#value: *v,
                    r#name: id.to_raw(),
                })
                .collect()
        }),
        r#bit_defs: typ.bit_defs.as_ref().map_or_else(Vec::new, |b| {
            b.bits
                .iter()
                .map(|(pos, id)| BitDef {
                    r#position: *pos,
                    r#name: id.to_raw(),
                })
                .collect()
        }),
        ..Default::default()
    };

    // Set optional constraint fields
    if let Some(size) = &typ.size {
        result.set_size(serialize_size_constraint(size));
    }
    if let Some(range) = &typ.value_range {
        result.set_range(serialize_value_constraint(range));
    }

    result
}

fn serialize_size_constraint(constraint: &wasmib_core::model::SizeConstraint) -> SerializedConstraint {
    SerializedConstraint {
        r#ranges: constraint
            .ranges
            .iter()
            .map(|(min, max)| Range {
                r#min: i64::from(*min),
                r#max: i64::from(*max),
            })
            .collect(),
    }
}

fn serialize_value_constraint(constraint: &wasmib_core::model::ValueConstraint) -> SerializedConstraint {
    SerializedConstraint {
        r#ranges: constraint
            .ranges
            .iter()
            .map(|(min, max)| Range {
                r#min: range_bound_to_i64(min),
                r#max: range_bound_to_i64(max),
            })
            .collect(),
    }
}

fn range_bound_to_i64(bound: &wasmib_core::model::RangeBound) -> i64 {
    match bound {
        wasmib_core::model::RangeBound::Signed(v) => *v,
        wasmib_core::model::RangeBound::Unsigned(v) => *v as i64,
    }
}

fn serialize_notification(notif: &ResolvedNotification) -> SerializedNotification {
    SerializedNotification {
        r#node: notif.node.to_raw(),
        r#module: notif.module.to_raw(),
        r#name: notif.name.to_raw(),
        r#status: u32::from(notif.status.as_u8()),
        r#description: notif.description.map_or(0, |id| id.to_raw()),
        r#reference: notif.reference.map_or(0, |id| id.to_raw()),
        r#objects: notif.objects.iter().map(|id| id.to_raw()).collect(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use wasmib_core::model::{Access, BaseType, Model, NodeKind, Status};

    #[test]
    fn test_serialize_empty_model() {
        let model = Model::new();
        let serialized = from_model(&model, None);

        assert_eq!(serialized.r#version, SCHEMA_VERSION);
        assert!(serialized.r#fingerprint.is_empty());
        assert!(serialized.r#modules.is_empty());
        assert!(serialized.r#nodes.is_empty());
        assert!(serialized.r#types.is_empty());
        assert!(serialized.r#objects.is_empty());
        assert!(serialized.r#notifications.is_empty());
        assert!(serialized.r#roots.is_empty());
    }

    #[test]
    fn test_serialize_with_fingerprint() {
        let model = Model::new();
        let fp = [42u8; 32];
        let serialized = from_model(&model, Some(fp));

        assert_eq!(serialized.r#fingerprint.as_slice(), &fp);
    }

    #[test]
    fn test_to_bytes_empty_model() {
        let model = Model::new();
        let bytes = to_bytes(&model, None);

        // Should produce non-empty protobuf bytes
        assert!(!bytes.is_empty());
    }

    #[test]
    fn test_node_kind_round_trip() {
        for i in 0..10u8 {
            let kind = NodeKind::from_u8(i).unwrap();
            assert_eq!(kind.as_u8(), i);
        }
        assert!(NodeKind::from_u8(10).is_none());
    }

    #[test]
    fn test_access_round_trip() {
        for i in 0..6u8 {
            let access = Access::from_u8(i).unwrap();
            assert_eq!(access.as_u8(), i);
        }
        assert!(Access::from_u8(6).is_none());
    }

    #[test]
    fn test_status_round_trip() {
        for i in 0..3u8 {
            let status = Status::from_u8(i).unwrap();
            assert_eq!(status.as_u8(), i);
        }
        assert!(Status::from_u8(3).is_none());
    }

    #[test]
    fn test_base_type_round_trip() {
        for i in 0..12u8 {
            let base = BaseType::from_u8(i).unwrap();
            assert_eq!(base.as_u8(), i);
        }
        assert!(BaseType::from_u8(12).is_none());
    }
}
