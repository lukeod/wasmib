//! FFI serialization layer for cross-language model export.
//!
//! This module provides serialization using Protocol Buffers for cross-language
//! deserialization. The protobuf types are generated by micropb from wasmib.proto.
//!
//! # Design Principles
//!
//! 1. **Flat structures** - No nested references, use indices instead
//! 2. **Compact enums** - Use u8 representation for enums
//! 3. **String table** - All strings are interned, referenced by u32 ID
//! 4. **Versioned** - Schema version in envelope for forward compatibility
//! 5. **Self-contained** - Indices can be rebuilt from serialized data

use alloc::string::String;
use alloc::vec::Vec;
use core::fmt;
use micropb::{MessageDecode, MessageEncode, PbDecoder};
use wasmib_core::model::{
    Access, BaseType, BitDefinitions, DefVal, EnumValues, IndexItem, IndexSpec, Model, ModelParts,
    ModuleId, NodeDefinition, NodeId, NodeKind, NotificationId, ObjectId, OidNode, RangeBound,
    ResolvedModule, ResolvedNotification, ResolvedObject, ResolvedType, Revision, SizeConstraint,
    Status, StrId, StringInterner, TypeId, UnresolvedImport as CoreUnresolvedImport,
    UnresolvedImportReason, UnresolvedIndex as CoreUnresolvedIndex,
    UnresolvedNotificationObject as CoreUnresolvedNotificationObject,
    UnresolvedOid as CoreUnresolvedOid, UnresolvedReferences, UnresolvedType as CoreUnresolvedType,
    ValueConstraint,
};

// Include generated protobuf types (with warnings suppressed for generated code)
#[allow(
    unused_imports,
    unused_parens,
    unused_variables,
    non_camel_case_types,
    non_snake_case,
    clippy::all,
    clippy::pedantic
)]
mod proto {
    include!(concat!(env!("OUT_DIR"), "/wasmib.rs"));
}
use proto::wasmib_;

/// Current schema version. Bump on any breaking change to serialized format.
pub const SCHEMA_VERSION: u32 = 1;

/// Re-export the generated types for external use
pub use wasmib_::*;

/// Create a serialized model from a resolved Model.
#[must_use]
#[allow(clippy::cast_possible_truncation)] // Counts will never exceed u32::MAX
pub fn from_model(model: &Model, fingerprint: Option<[u8; 32]>) -> SerializedModel {
    // 1. Serialize string interner
    let (strings_data, strings_offsets) = serialize_strings(model.strings());

    // 2. Serialize modules
    let modules: Vec<_> = model.modules().map(serialize_module).collect();

    // 3. Serialize nodes
    let nodes: Vec<_> = (0..model.node_count())
        .filter_map(|i| {
            wasmib_core::model::NodeId::from_index(i)
                .and_then(|id| model.get_node(id))
                .map(serialize_node)
        })
        .collect();

    // 4. Serialize types
    let types: Vec<_> = (0..model.type_count())
        .filter_map(|i| {
            wasmib_core::model::TypeId::from_index(i)
                .and_then(|id| model.get_type(id))
                .map(serialize_type)
        })
        .collect();

    // 5. Serialize objects
    let objects: Vec<_> = (0..model.object_count())
        .filter_map(|i| {
            wasmib_core::model::ObjectId::from_index(i)
                .and_then(|id| model.get_object(id))
                .map(serialize_object)
        })
        .collect();

    // 6. Serialize notifications
    let notifications: Vec<_> = (0..model.notification_count())
        .filter_map(|i| {
            wasmib_core::model::NotificationId::from_index(i)
                .and_then(|id| model.get_notification(id))
                .map(serialize_notification)
        })
        .collect();

    // 7. Get roots
    let roots: Vec<_> = model.root_ids().iter().map(|id| id.to_raw()).collect();

    // 8. Get unresolved references with details
    let unresolved = model.unresolved();

    // Serialize unresolved details
    let unresolved_import_details: Vec<_> = unresolved
        .imports
        .iter()
        .map(serialize_unresolved_import)
        .collect();
    let unresolved_type_details: Vec<_> = unresolved
        .types
        .iter()
        .map(serialize_unresolved_type)
        .collect();
    let unresolved_oid_details: Vec<_> = unresolved
        .oids
        .iter()
        .map(serialize_unresolved_oid)
        .collect();
    let unresolved_index_details: Vec<_> = unresolved
        .indexes
        .iter()
        .map(serialize_unresolved_index)
        .collect();
    let unresolved_notif_details: Vec<_> = unresolved
        .notification_objects
        .iter()
        .map(serialize_unresolved_notif)
        .collect();

    // Use struct literal for repeated fields, then set scalar fields
    SerializedModel {
        r#version: SCHEMA_VERSION,
        r#fingerprint: fingerprint.map_or_else(Vec::new, |fp| fp.to_vec()),
        strings_data,
        strings_offsets,
        modules,
        nodes,
        types,
        objects,
        notifications,
        roots,
        r#unresolved_imports: unresolved.imports.len() as u32,
        r#unresolved_types: unresolved.types.len() as u32,
        r#unresolved_oids: unresolved.oids.len() as u32,
        r#unresolved_indexes: unresolved.indexes.len() as u32,
        r#unresolved_notification_objects: unresolved.notification_objects.len() as u32,
        unresolved_import_details,
        unresolved_type_details,
        unresolved_oid_details,
        unresolved_index_details,
        unresolved_notif_details,
    }
}

/// Serialize a model to protobuf bytes.
#[must_use]
#[allow(clippy::missing_panics_doc)] // Encoding only fails on OOM
pub fn to_bytes(model: &Model, fingerprint: Option<[u8; 32]>) -> Vec<u8> {
    let serialized = from_model(model, fingerprint);
    let mut buf = Vec::new();
    serialized
        .encode(&mut micropb::PbEncoder::new(&mut buf))
        .expect("serialization should not fail");
    buf
}

/// Error during protobuf deserialization.
#[derive(Debug)]
pub enum DecodeError {
    /// Protobuf decode failed.
    ProtobufDecode(micropb::DecodeError<core::convert::Infallible>),
    /// Invalid enum value.
    InvalidEnumValue { field: &'static str, value: u32 },
    /// Invalid ID (zero where non-zero expected).
    InvalidId { field: &'static str },
}

impl fmt::Display for DecodeError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::ProtobufDecode(e) => write!(f, "protobuf decode error: {e:?}"),
            Self::InvalidEnumValue { field, value } => {
                write!(f, "invalid enum value {value} for field {field}")
            }
            Self::InvalidId { field } => write!(f, "invalid zero ID for field {field}"),
        }
    }
}

impl From<micropb::DecodeError<core::convert::Infallible>> for DecodeError {
    fn from(e: micropb::DecodeError<core::convert::Infallible>) -> Self {
        Self::ProtobufDecode(e)
    }
}

/// Deserialize a model from protobuf bytes.
///
/// # Errors
///
/// Returns an error if the protobuf data is invalid or contains invalid enum values.
pub fn from_bytes(bytes: &[u8]) -> Result<Model, DecodeError> {
    let mut msg = SerializedModel::default();
    msg.decode(&mut PbDecoder::new(bytes), bytes.len())?;
    to_model(msg)
}

/// Get the schema version from serialized bytes without fully decoding.
///
/// This reads only the version field from the protobuf envelope.
///
/// # Errors
///
/// Returns an error if the protobuf header cannot be read.
pub fn get_version(bytes: &[u8]) -> Result<u32, DecodeError> {
    let mut msg = SerializedModel::default();
    msg.decode(&mut PbDecoder::new(bytes), bytes.len())?;
    Ok(msg.r#version)
}

/// Get the fingerprint from serialized bytes without fully decoding.
///
/// # Errors
///
/// Returns an error if the protobuf header cannot be read.
pub fn get_fingerprint(bytes: &[u8]) -> Result<Option<[u8; 32]>, DecodeError> {
    let mut msg = SerializedModel::default();
    msg.decode(&mut PbDecoder::new(bytes), bytes.len())?;
    if msg.r#fingerprint.is_empty() {
        Ok(None)
    } else if msg.r#fingerprint.len() == 32 {
        let mut fp = [0u8; 32];
        fp.copy_from_slice(&msg.r#fingerprint);
        Ok(Some(fp))
    } else {
        Ok(None) // Invalid fingerprint length, treat as missing
    }
}

/// Convert a `SerializedModel` to a Model.
fn to_model(msg: SerializedModel) -> Result<Model, DecodeError> {
    // 1. Reconstruct string interner offsets
    // The StringOffset messages have (start, end) pairs for each string.
    // The interner expects cumulative offsets [0, end1, end2, ...], so we take the starts.
    let strings_offsets: Vec<u32> = msg.r#strings_offsets.iter().map(|o| o.r#start).collect();

    // 2. Deserialize modules
    let modules: Result<Vec<_>, _> = msg.r#modules.into_iter().map(deserialize_module).collect();
    let modules = modules?;

    // 3. Deserialize nodes
    let nodes: Result<Vec<_>, _> = msg.r#nodes.into_iter().map(deserialize_node).collect();
    let nodes = nodes?;

    // 4. Deserialize types
    let types: Result<Vec<_>, _> = msg.r#types.into_iter().map(deserialize_type).collect();
    let types = types?;

    // 5. Deserialize objects
    let objects: Result<Vec<_>, _> = msg.r#objects.into_iter().map(deserialize_object).collect();
    let objects = objects?;

    // 6. Deserialize notifications
    let notifications: Result<Vec<_>, _> = msg
        .r#notifications
        .into_iter()
        .map(deserialize_notification)
        .collect();
    let notifications = notifications?;

    // 7. Deserialize roots
    let roots: Vec<NodeId> = msg
        .r#roots
        .into_iter()
        .filter_map(NodeId::from_raw)
        .collect();

    // 8. Create unresolved references (counts only, details not preserved)
    let unresolved = UnresolvedReferences::default();
    // Note: The serialized format only stores counts, not the actual unresolved references.
    // This is acceptable since unresolved references are primarily for diagnostics during
    // resolution, not for deserialized cached models.

    let parts = ModelParts {
        strings_data: msg.r#strings_data,
        strings_offsets,
        modules,
        nodes,
        types,
        objects,
        notifications,
        roots,
        unresolved,
    };

    Ok(Model::from_parts(parts))
}

fn deserialize_module(msg: SerializedModule) -> Result<ResolvedModule, DecodeError> {
    let name = StrId::from_raw(msg.r#name).ok_or(DecodeError::InvalidId {
        field: "module.name",
    })?;

    let mut module = ResolvedModule::new(name);
    module.last_updated = StrId::from_raw(msg.r#last_updated);
    module.contact_info = StrId::from_raw(msg.r#contact_info);
    module.organization = StrId::from_raw(msg.r#organization);
    module.description = StrId::from_raw(msg.r#description);
    module.revisions = msg
        .r#revisions
        .into_iter()
        .filter_map(deserialize_revision)
        .collect();

    Ok(module)
}

fn deserialize_revision(msg: SerializedRevision) -> Option<Revision> {
    let date = StrId::from_raw(msg.r#date)?;
    let description = StrId::from_raw(msg.r#description)?;
    Some(Revision::new(date, description))
}

#[allow(clippy::cast_possible_truncation)] // Enum values fit in u8
fn deserialize_node(msg: SerializedNode) -> Result<OidNode, DecodeError> {
    let kind = NodeKind::from_u8(msg.r#kind as u8).ok_or(DecodeError::InvalidEnumValue {
        field: "node.kind",
        value: msg.r#kind,
    })?;

    let mut node = OidNode::new(msg.r#subid, NodeId::from_raw(msg.r#parent));
    node.kind = kind;
    node.children = msg
        .r#children
        .into_iter()
        .filter_map(NodeId::from_raw)
        .collect();
    node.definitions = msg
        .r#definitions
        .into_iter()
        .filter_map(deserialize_node_def)
        .collect();

    Ok(node)
}

fn deserialize_node_def(msg: SerializedNodeDef) -> Option<NodeDefinition> {
    let module = ModuleId::from_raw(msg.r#module)?;
    let label = StrId::from_raw(msg.r#label)?;
    let mut def = NodeDefinition::new(module, label);
    def.object = ObjectId::from_raw(msg.r#object);
    def.notification = NotificationId::from_raw(msg.r#notification);
    Some(def)
}

#[allow(clippy::cast_possible_truncation)] // Enum values fit in u8
fn deserialize_type(msg: SerializedType) -> Result<ResolvedType, DecodeError> {
    let module = ModuleId::from_raw(msg.r#module).ok_or(DecodeError::InvalidId {
        field: "type.module",
    })?;
    let name = StrId::from_raw(msg.r#name).ok_or(DecodeError::InvalidId { field: "type.name" })?;
    let base = BaseType::from_u8(msg.r#base as u8).ok_or(DecodeError::InvalidEnumValue {
        field: "type.base",
        value: msg.r#base,
    })?;
    let status = Status::from_u8(msg.r#status as u8).ok_or(DecodeError::InvalidEnumValue {
        field: "type.status",
        value: msg.r#status,
    })?;

    let mut typ = ResolvedType::new(name, module, base);
    typ.parent_type = TypeId::from_raw(msg.r#parent);
    typ.status = status;
    typ.is_textual_convention = msg.r#is_tc;
    typ.hint = StrId::from_raw(msg.r#hint);
    typ.description = StrId::from_raw(msg.r#description);

    // Deserialize size constraint (use accessor method for optional field)
    if let Some(size_msg) = msg.r#size() {
        typ.size = Some(deserialize_size_constraint(size_msg));
    }

    // Deserialize value range constraint (use accessor method for optional field)
    if let Some(range_msg) = msg.r#range() {
        typ.value_range = Some(deserialize_value_constraint(range_msg));
    }

    // Deserialize enum values
    if !msg.r#enum_values.is_empty() {
        let values: Vec<(i64, StrId)> = msg
            .r#enum_values
            .into_iter()
            .filter_map(|ev| StrId::from_raw(ev.r#name).map(|name| (ev.r#value, name)))
            .collect();
        if !values.is_empty() {
            typ.enum_values = Some(EnumValues::new(values));
        }
    }

    // Deserialize bit definitions
    if !msg.r#bit_defs.is_empty() {
        let bits: Vec<(u32, StrId)> = msg
            .r#bit_defs
            .into_iter()
            .filter_map(|bd| StrId::from_raw(bd.r#name).map(|name| (bd.r#position, name)))
            .collect();
        if !bits.is_empty() {
            typ.bit_defs = Some(BitDefinitions::new(bits));
        }
    }

    Ok(typ)
}

#[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)] // Protobuf uses i64, sizes fit u32
fn deserialize_size_constraint(msg: &SerializedConstraint) -> SizeConstraint {
    SizeConstraint {
        ranges: msg
            .r#ranges
            .iter()
            .map(|r| (r.r#min as u32, r.r#max as u32))
            .collect(),
    }
}

fn deserialize_value_constraint(msg: &SerializedConstraint) -> ValueConstraint {
    ValueConstraint {
        ranges: msg
            .r#ranges
            .iter()
            .map(|r| (RangeBound::Signed(r.r#min), RangeBound::Signed(r.r#max)))
            .collect(),
    }
}

#[allow(clippy::cast_possible_truncation)] // Enum values fit in u8
fn deserialize_object(msg: SerializedObject) -> Result<ResolvedObject, DecodeError> {
    let node = NodeId::from_raw(msg.r#node).ok_or(DecodeError::InvalidId {
        field: "object.node",
    })?;
    let module = ModuleId::from_raw(msg.r#module).ok_or(DecodeError::InvalidId {
        field: "object.module",
    })?;
    let name = StrId::from_raw(msg.r#name).ok_or(DecodeError::InvalidId {
        field: "object.name",
    })?;
    let access = Access::from_u8(msg.r#access as u8).ok_or(DecodeError::InvalidEnumValue {
        field: "object.access",
        value: msg.r#access,
    })?;
    let status = Status::from_u8(msg.r#status as u8).ok_or(DecodeError::InvalidEnumValue {
        field: "object.status",
        value: msg.r#status,
    })?;

    let mut obj = ResolvedObject::new(node, module, name, TypeId::from_raw(msg.r#type_id), access);
    obj.status = status;
    obj.description = StrId::from_raw(msg.r#description);
    obj.units = StrId::from_raw(msg.r#units);
    obj.reference = StrId::from_raw(msg.r#reference);
    obj.augments = NodeId::from_raw(msg.r#augments);

    // Deserialize index (use accessor method for optional field)
    if let Some(index_msg) = msg.r#index() {
        let items: Vec<IndexItem> = index_msg
            .r#items
            .iter()
            .filter_map(|item| {
                NodeId::from_raw(item.r#object).map(|obj| IndexItem::new(obj, item.r#implied))
            })
            .collect();
        if !items.is_empty() {
            obj.index = Some(IndexSpec::new(items));
        }
    }

    // Deserialize defval (use accessor method for optional field)
    if let Some(defval_msg) = msg.r#defval() {
        obj.defval = deserialize_defval(defval_msg);
    }

    // Deserialize inline enum
    if !msg.r#inline_enum.is_empty() {
        let values: Vec<(i64, StrId)> = msg
            .r#inline_enum
            .into_iter()
            .filter_map(|ev| StrId::from_raw(ev.r#name).map(|name| (ev.r#value, name)))
            .collect();
        if !values.is_empty() {
            obj.inline_enum = Some(EnumValues::new(values));
        }
    }

    // Deserialize inline bits
    if !msg.r#inline_bits.is_empty() {
        let bits: Vec<(u32, StrId)> = msg
            .r#inline_bits
            .into_iter()
            .filter_map(|bd| StrId::from_raw(bd.r#name).map(|name| (bd.r#position, name)))
            .collect();
        if !bits.is_empty() {
            obj.inline_bits = Some(BitDefinitions::new(bits));
        }
    }

    Ok(obj)
}

fn deserialize_defval(msg: &SerializedDefVal) -> Option<DefVal> {
    match msg.r#kind {
        // Use accessor methods which return Option<&T> for optional fields
        0 => msg.r#int_val().copied().map(DefVal::Integer),
        1 => msg.r#uint_val().copied().map(DefVal::Unsigned),
        2 => msg
            .r#str_val()
            .and_then(|&v| StrId::from_raw(v))
            .map(DefVal::String),
        3 => msg.r#raw_str().map(|s| DefVal::HexString(s.clone())),
        4 => msg.r#raw_str().map(|s| DefVal::BinaryString(s.clone())),
        5 => msg
            .r#str_val()
            .and_then(|&v| StrId::from_raw(v))
            .map(DefVal::Enum),
        6 => {
            let bits: Vec<StrId> = msg
                .r#bits_val
                .iter()
                .copied()
                .filter_map(StrId::from_raw)
                .collect();
            Some(DefVal::Bits(bits))
        }
        7 => Some(DefVal::OidRef {
            node: msg.r#node_val().and_then(|&v| NodeId::from_raw(v)),
            symbol: msg.r#str_val().and_then(|&v| StrId::from_raw(v)),
        }),
        _ => None,
    }
}

#[allow(clippy::cast_possible_truncation)] // Enum values fit in u8
fn deserialize_notification(
    msg: SerializedNotification,
) -> Result<ResolvedNotification, DecodeError> {
    let node = NodeId::from_raw(msg.r#node).ok_or(DecodeError::InvalidId {
        field: "notification.node",
    })?;
    let module = ModuleId::from_raw(msg.r#module).ok_or(DecodeError::InvalidId {
        field: "notification.module",
    })?;
    let name = StrId::from_raw(msg.r#name).ok_or(DecodeError::InvalidId {
        field: "notification.name",
    })?;
    let status = Status::from_u8(msg.r#status as u8).ok_or(DecodeError::InvalidEnumValue {
        field: "notification.status",
        value: msg.r#status,
    })?;

    let mut notif = ResolvedNotification::new(node, module, name);
    notif.status = status;
    notif.description = StrId::from_raw(msg.r#description);
    notif.reference = StrId::from_raw(msg.r#reference);
    notif.objects = msg
        .r#objects
        .into_iter()
        .filter_map(NodeId::from_raw)
        .collect();

    Ok(notif)
}

/// Serialize the string interner to (data, offsets).
#[allow(clippy::cast_possible_truncation)] // String data won't exceed u32::MAX
fn serialize_strings(interner: &StringInterner) -> (String, Vec<StringOffset>) {
    let (data, offsets) = interner.export_parts();

    // Convert offsets to StringOffset messages
    let offset_msgs: Vec<StringOffset> = if offsets.is_empty() {
        Vec::new()
    } else {
        offsets
            .windows(2)
            .map(|w| StringOffset {
                r#start: w[0],
                r#end: w[1],
            })
            .chain(core::iter::once(StringOffset {
                r#start: *offsets.last().unwrap_or(&0),
                r#end: data.len() as u32,
            }))
            .collect()
    };

    (data, offset_msgs)
}

fn serialize_module(module: &ResolvedModule) -> SerializedModule {
    SerializedModule {
        r#name: module.name.to_raw(),
        r#last_updated: module
            .last_updated
            .map_or(0, wasmib_core::model::StrId::to_raw),
        r#contact_info: module
            .contact_info
            .map_or(0, wasmib_core::model::StrId::to_raw),
        r#organization: module
            .organization
            .map_or(0, wasmib_core::model::StrId::to_raw),
        r#description: module
            .description
            .map_or(0, wasmib_core::model::StrId::to_raw),
        r#revisions: module.revisions.iter().map(serialize_revision).collect(),
    }
}

fn serialize_revision(rev: &Revision) -> SerializedRevision {
    SerializedRevision {
        r#date: rev.date.to_raw(),
        r#description: rev.description.to_raw(),
    }
}

fn serialize_node(node: &OidNode) -> SerializedNode {
    SerializedNode {
        r#subid: node.subid,
        r#parent: node.parent.map_or(0, wasmib_core::model::NodeId::to_raw),
        r#children: node.children.iter().map(|id| id.to_raw()).collect(),
        r#kind: u32::from(node.kind.as_u8()),
        r#definitions: node.definitions.iter().map(serialize_node_def).collect(),
    }
}

fn serialize_node_def(def: &wasmib_core::model::NodeDefinition) -> SerializedNodeDef {
    SerializedNodeDef {
        r#module: def.module.to_raw(),
        r#label: def.label.to_raw(),
        r#object: def.object.map_or(0, wasmib_core::model::ObjectId::to_raw),
        r#notification: def
            .notification
            .map_or(0, wasmib_core::model::NotificationId::to_raw),
    }
}

fn serialize_object(obj: &ResolvedObject) -> SerializedObject {
    let mut result = SerializedObject {
        r#node: obj.node.to_raw(),
        r#module: obj.module.to_raw(),
        r#name: obj.name.to_raw(),
        r#type_id: obj.type_id.map_or(0, wasmib_core::model::TypeId::to_raw),
        r#access: u32::from(obj.access.as_u8()),
        r#status: u32::from(obj.status.as_u8()),
        r#description: obj.description.map_or(0, wasmib_core::model::StrId::to_raw),
        r#units: obj.units.map_or(0, wasmib_core::model::StrId::to_raw),
        r#reference: obj.reference.map_or(0, wasmib_core::model::StrId::to_raw),
        r#augments: obj.augments.map_or(0, wasmib_core::model::NodeId::to_raw),
        r#inline_enum: obj.inline_enum.as_ref().map_or_else(Vec::new, |e| {
            e.values
                .iter()
                .map(|(v, id)| EnumValue {
                    r#value: *v,
                    r#name: id.to_raw(),
                })
                .collect()
        }),
        r#inline_bits: obj.inline_bits.as_ref().map_or_else(Vec::new, |b| {
            b.bits
                .iter()
                .map(|(pos, id)| BitDef {
                    r#position: *pos,
                    r#name: id.to_raw(),
                })
                .collect()
        }),
        ..Default::default()
    };

    // Set optional fields using setters (which update _has)
    if let Some(index) = &obj.index {
        result.set_index(serialize_index(index));
    }
    if let Some(defval) = &obj.defval {
        result.set_defval(serialize_defval(defval));
    }

    result
}

fn serialize_index(index: &wasmib_core::model::IndexSpec) -> SerializedIndex {
    SerializedIndex {
        r#items: index.items.iter().map(serialize_index_item).collect(),
    }
}

fn serialize_index_item(item: &IndexItem) -> SerializedIndexItem {
    SerializedIndexItem {
        r#object: item.object.to_raw(),
        r#implied: item.implied,
    }
}

fn serialize_defval(defval: &DefVal) -> SerializedDefVal {
    let mut result = SerializedDefVal::default();

    match defval {
        DefVal::Integer(v) => {
            result.set_kind(0);
            result.set_int_val(*v);
        }
        DefVal::Unsigned(v) => {
            result.set_kind(1);
            result.set_uint_val(*v);
        }
        DefVal::String(id) => {
            result.set_kind(2);
            result.set_str_val(id.to_raw());
        }
        DefVal::HexString(s) => {
            result.set_kind(3);
            result.set_raw_str(s.clone());
        }
        DefVal::BinaryString(s) => {
            result.set_kind(4);
            result.set_raw_str(s.clone());
        }
        DefVal::Enum(id) => {
            result.set_kind(5);
            result.set_str_val(id.to_raw());
        }
        DefVal::Bits(ids) => {
            result.set_kind(6);
            result.r#bits_val = ids.iter().map(|id| id.to_raw()).collect();
        }
        DefVal::OidRef { node, symbol } => {
            result.set_kind(7);
            if let Some(id) = symbol {
                result.set_str_val(id.to_raw());
            }
            if let Some(id) = node {
                result.set_node_val(id.to_raw());
            }
        }
    }

    result
}

fn serialize_type(typ: &ResolvedType) -> SerializedType {
    let mut result = SerializedType {
        r#module: typ.module.to_raw(),
        r#name: typ.name.to_raw(),
        r#base: u32::from(typ.base.as_u8()),
        r#parent: typ
            .parent_type
            .map_or(0, wasmib_core::model::TypeId::to_raw),
        r#status: u32::from(typ.status.as_u8()),
        r#is_tc: typ.is_textual_convention,
        r#hint: typ.hint.map_or(0, wasmib_core::model::StrId::to_raw),
        r#description: typ.description.map_or(0, wasmib_core::model::StrId::to_raw),
        r#enum_values: typ.enum_values.as_ref().map_or_else(Vec::new, |e| {
            e.values
                .iter()
                .map(|(v, id)| EnumValue {
                    r#value: *v,
                    r#name: id.to_raw(),
                })
                .collect()
        }),
        r#bit_defs: typ.bit_defs.as_ref().map_or_else(Vec::new, |b| {
            b.bits
                .iter()
                .map(|(pos, id)| BitDef {
                    r#position: *pos,
                    r#name: id.to_raw(),
                })
                .collect()
        }),
        ..Default::default()
    };

    // Set optional constraint fields
    if let Some(size) = &typ.size {
        result.set_size(serialize_size_constraint(size));
    }
    if let Some(range) = &typ.value_range {
        result.set_range(serialize_value_constraint(range));
    }

    result
}

fn serialize_size_constraint(
    constraint: &wasmib_core::model::SizeConstraint,
) -> SerializedConstraint {
    SerializedConstraint {
        r#ranges: constraint
            .ranges
            .iter()
            .map(|(min, max)| Range {
                r#min: i64::from(*min),
                r#max: i64::from(*max),
            })
            .collect(),
    }
}

fn serialize_value_constraint(
    constraint: &wasmib_core::model::ValueConstraint,
) -> SerializedConstraint {
    SerializedConstraint {
        r#ranges: constraint
            .ranges
            .iter()
            .map(|(min, max)| Range {
                r#min: range_bound_to_i64(min),
                r#max: range_bound_to_i64(max),
            })
            .collect(),
    }
}

#[allow(clippy::cast_possible_wrap)] // MIB range values won't exceed i64::MAX
fn range_bound_to_i64(bound: &wasmib_core::model::RangeBound) -> i64 {
    match bound {
        wasmib_core::model::RangeBound::Signed(v) => *v,
        wasmib_core::model::RangeBound::Unsigned(v) => *v as i64,
    }
}

fn serialize_notification(notif: &ResolvedNotification) -> SerializedNotification {
    SerializedNotification {
        r#node: notif.node.to_raw(),
        r#module: notif.module.to_raw(),
        r#name: notif.name.to_raw(),
        r#status: u32::from(notif.status.as_u8()),
        r#description: notif
            .description
            .map_or(0, wasmib_core::model::StrId::to_raw),
        r#reference: notif.reference.map_or(0, wasmib_core::model::StrId::to_raw),
        r#objects: notif.objects.iter().map(|id| id.to_raw()).collect(),
    }
}

fn serialize_unresolved_import(imp: &CoreUnresolvedImport) -> UnresolvedImport {
    UnresolvedImport {
        r#importing_module: imp.importing_module.to_raw(),
        r#from_module: imp.from_module.to_raw(),
        r#symbol: imp.symbol.to_raw(),
        r#reason: match imp.reason {
            UnresolvedImportReason::ModuleNotFound => 0,
            UnresolvedImportReason::SymbolNotExported => 1,
        },
    }
}

fn serialize_unresolved_type(typ: &CoreUnresolvedType) -> UnresolvedType {
    UnresolvedType {
        r#module: typ.module.to_raw(),
        r#referrer: typ.referrer.to_raw(),
        r#referenced: typ.referenced.to_raw(),
    }
}

fn serialize_unresolved_oid(oid: &CoreUnresolvedOid) -> UnresolvedOid {
    UnresolvedOid {
        r#module: oid.module.to_raw(),
        r#definition: oid.definition.to_raw(),
        r#component: oid.component.to_raw(),
    }
}

fn serialize_unresolved_index(idx: &CoreUnresolvedIndex) -> UnresolvedIndex {
    UnresolvedIndex {
        r#module: idx.module.to_raw(),
        r#row: idx.row.to_raw(),
        r#index_object: idx.index_object.to_raw(),
    }
}

fn serialize_unresolved_notif(
    notif: &CoreUnresolvedNotificationObject,
) -> UnresolvedNotificationObject {
    UnresolvedNotificationObject {
        r#module: notif.module.to_raw(),
        r#notification: notif.notification.to_raw(),
        r#object: notif.object.to_raw(),
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use wasmib_core::model::{
        Access, BaseType, Model, NodeKind, OidNode, ResolvedModule, ResolvedType, Status,
    };

    #[test]
    fn test_round_trip_empty_model() {
        let model = Model::new();
        let bytes = to_bytes(&model, None);
        let restored = from_bytes(&bytes).expect("decode should succeed");

        assert_eq!(restored.module_count(), 0);
        assert_eq!(restored.node_count(), 0);
        assert_eq!(restored.type_count(), 0);
        assert_eq!(restored.object_count(), 0);
        assert_eq!(restored.notification_count(), 0);
    }

    #[test]
    fn test_round_trip_with_fingerprint() {
        let model = Model::new();
        let fp = [42u8; 32];
        let bytes = to_bytes(&model, Some(fp));

        // Verify we can extract fingerprint
        let extracted_fp = get_fingerprint(&bytes).expect("should extract fingerprint");
        assert_eq!(extracted_fp, Some(fp));

        // Verify full decode works
        let restored = from_bytes(&bytes).expect("decode should succeed");
        assert_eq!(restored.module_count(), 0);
    }

    #[test]
    fn test_round_trip_with_content() {
        let mut model = Model::new();

        // Add a module
        let mod_name = model.intern("TEST-MIB");
        let module = ResolvedModule::new(mod_name);
        let mod_id = model.add_module(module).expect("should add module");

        // Add a node
        let mut node = OidNode::new(1, None);
        node.kind = NodeKind::Scalar;
        let node_id = model.add_node(node).expect("should add node");
        model.add_root(node_id);

        // Add a type
        let type_name = model.intern("TestType");
        let mut typ = ResolvedType::new(type_name, mod_id, BaseType::Integer32);
        typ.description = Some(model.intern("A test type"));
        model.add_type(typ).expect("should add type");

        // Serialize and deserialize
        let bytes = to_bytes(&model, None);
        let restored = from_bytes(&bytes).expect("decode should succeed");

        // Verify counts
        assert_eq!(restored.module_count(), 1);
        assert_eq!(restored.node_count(), 1);
        assert_eq!(restored.type_count(), 1);

        // Verify module name
        let restored_mod = restored.get_module_by_name("TEST-MIB");
        assert!(restored_mod.is_some(), "Module TEST-MIB should be found");

        // Verify node kind
        let root = restored.roots().next().expect("should have root");
        assert_eq!(root.kind, NodeKind::Scalar);
    }

    #[test]
    fn test_serialize_empty_model() {
        let model = Model::new();
        let serialized = from_model(&model, None);

        assert_eq!(serialized.r#version, SCHEMA_VERSION);
        assert!(serialized.r#fingerprint.is_empty());
        assert!(serialized.r#modules.is_empty());
        assert!(serialized.r#nodes.is_empty());
        assert!(serialized.r#types.is_empty());
        assert!(serialized.r#objects.is_empty());
        assert!(serialized.r#notifications.is_empty());
        assert!(serialized.r#roots.is_empty());
    }

    #[test]
    fn test_serialize_with_fingerprint() {
        let model = Model::new();
        let fp = [42u8; 32];
        let serialized = from_model(&model, Some(fp));

        assert_eq!(serialized.r#fingerprint.as_slice(), &fp);
    }

    #[test]
    fn test_to_bytes_empty_model() {
        let model = Model::new();
        let bytes = to_bytes(&model, None);

        // Should produce non-empty protobuf bytes
        assert!(!bytes.is_empty());
    }

    #[test]
    fn test_node_kind_round_trip() {
        for i in 0..10u8 {
            let kind = NodeKind::from_u8(i).unwrap();
            assert_eq!(kind.as_u8(), i);
        }
        assert!(NodeKind::from_u8(10).is_none());
    }

    #[test]
    fn test_access_round_trip() {
        for i in 0..6u8 {
            let access = Access::from_u8(i).unwrap();
            assert_eq!(access.as_u8(), i);
        }
        assert!(Access::from_u8(6).is_none());
    }

    #[test]
    fn test_status_round_trip() {
        for i in 0..3u8 {
            let status = Status::from_u8(i).unwrap();
            assert_eq!(status.as_u8(), i);
        }
        assert!(Status::from_u8(3).is_none());
    }

    #[test]
    fn test_base_type_round_trip() {
        for i in 0..12u8 {
            let base = BaseType::from_u8(i).unwrap();
            assert_eq!(base.as_u8(), i);
        }
        assert!(BaseType::from_u8(12).is_none());
    }
}
